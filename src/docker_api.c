/*
** EPITECH PROJECT, 2025
** docker_api.c
** File description:
** This code is used to make a request to the Docker API
** It was been generated by an AI (ChatGPT) & modified by an human
*/
#include "docker.h"

static size_t write_to_buffer(void *contents, size_t size,
    size_t nmemb, void *userp)
{
    size_t total_size = size * nmemb;
    struct MemoryBuffer *mem = (struct MemoryBuffer *)userp;
    char *ptr = GC_REALLOC(mem->data, mem->size + total_size + 1);

    if (ptr == NULL) {
        fprintf(stderr, "Not enough memory to allocate buffer\n");
        return 0;
    }
    mem->data = ptr;
    memcpy(&(mem->data[mem->size]), contents, total_size);
    mem->size += total_size;
    mem->data[mem->size] = '\0';
    return total_size;
}

void init_curl(CURL *curl, char *url, struct MemoryBuffer *response)
{
    curl_easy_setopt(curl, CURLOPT_URL, url);
    curl_easy_setopt(curl, CURLOPT_UNIX_SOCKET_PATH, SOCKET_ADDRESS);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_to_buffer);
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, (void *)response);
}

char *make_api_request(char *url)
{
    CURL *curl;
    CURLcode res;
    struct MemoryBuffer response = {NULL, 0};

    response.data = NULL;
    response.size = 0;
    curl = curl_easy_init();
    if (!curl) {
        return NULL;
    }
    init_curl(curl, url, &response);
    res = curl_easy_perform(curl);
    curl_easy_cleanup(curl);
    if (res != CURLE_OK) {
        return NULL;
    } else {
        return response.data;
    }
}

void init_curl_post(CURL *curl, struct curl_slist **headers, char *json_data)
{
    curl_easy_setopt(curl, CURLOPT_POST, 1L);
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, json_data);
    *headers = curl_slist_append(*headers, "Content-Type: application/json");
    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, *headers);
}

static char *make_api_request_post_init(struct MemoryBuffer *response,
    CURL **curl_ptr)
{
    response->data = GC_MALLOC(1);
    if (!response->data) {
        fprintf(stderr, "Failed to allocate memory\n");
        return NULL;
    }
    response->data[0] = '\0';
    response->size = 0;
    *curl_ptr = curl_easy_init();
    if (!(*curl_ptr)) {
        GC_FREE(response->data);
        return NULL;
    }
    return response->data;
}

char *make_api_request_post(char *url, char *json_data)
{
    CURL *curl;
    CURLcode res;
    struct MemoryBuffer response = {NULL, 0};
    struct curl_slist *headers = NULL;

    response.data = make_api_request_post_init(&response, &curl);
    init_curl(curl, url, &response);
    init_curl_post(curl, &headers, json_data);
    res = curl_easy_perform(curl);
    curl_easy_cleanup(curl);
    curl_slist_free_all(headers);
    if (res != CURLE_OK) {
        GC_FREE(response.data);
        return NULL;
    } else {
        return response.data;
    }
}
